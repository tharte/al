# -*- org-confirm-babel-evaluate: nil -*- 
#+title:     A Cunning Plan
#+author:    
#+subtitle:   The Lambda Calculus, Lisp, Scheme, and R
#+date:    
#+language:   en
#+options:    H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+options:    TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

#+startup: beamer
#+latex_class: beamer
#+beamer_frame_level: 2
#+latex_class_options: [9pt]

#+latex_header:  \mode<beamer>{\usetheme[progressbar=frametitle]{metropolis}}
#+latex_header:  \usepackage{minted}
#+latex_header:  \usemintedstyle{colorful}
#+latex_header:  \usepackage[linesnumbered,ruled]{algorithm2e}
#+options:       tex:imagemagick
#+bind:          org-latex-image-default-width 0.5\linewidth $
#+bind:          org-latex-prefer-user-labels t

#+include:       /home/tharte/dot/include/newcommands.tex src latex
#+latex_header:  \newtheorem{defn}{Definition}[section]
#+latex_header:  \newtheorem{remark}{Remark}[section]
#+latex_header:  \usetikzlibrary{positioning}
#+latex_header:  \usetikzlibrary{shadows}
#+latex_header:  \usetikzlibrary{arrows}
#+latex_header:  \usetikzlibrary{matrix}

#+latex_header:  \usepackage{textgreek}
#+latex_header:  \usepackage[makeroom]{cancel}

#+latex_header:  \definecolor{lightgreen}{HTML}{90EE90}
#+latex_header:  \definecolor{lightblue}{rgb}{0.94,0.94,0.95}

# make the counter algocf overlay aware (e.g. when using algorithm2e with onslide)
# Source:    https://tex.stackexchange.com/questions/226929/making-algorithm2e-environments-overlay-aware-in-beamer
#+latex_header:  \resetcounteronoverlays{algocf}

#+latex_header: \author{Thomas P.~Harte}
#+latex_header: \institute{R/Finance 2024-05-18 \\ University of Illinois at Chicago}

# Source: https://tex.stackexchange.com/questions/132783/how-to-write-checkmark-in-latex
#+latex_header:  \def\checkmark{\textcolor{green}{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}}



# 
# SET-UP
#
#+BEGIN_SRC R :session :exports none :results silent :eval no
source("/home/tharte/dot/stats/cache/rfinance-2019/rfinance-2019-functions.R")
.init.proj(set.proj.dir=TRUE)
#+END_SRC


* Disclaimer
** Disclaimer
#+begin_export latex
    Thomas P. Harte (``the Author'') is providing
    this presentation and its contents (``the Content'') for educational
    purposes only at the \emph{R in Finance Conference\/}, 2024-05-18,
    Chicago, IL.  The Author is not a registered investment advisor,
    nor does the Author purport to offer investment advice,
    nor business advice. The opinions expressed in the Content 
    belong solely to the Author, and do not necessarily represent the 
    opinions of the Author's employers, nor any 
    organization, committee or other group with which the Author
    is affiliated.
\newline \newline
    THE AUTHOR SPECIFICALLY DISCLAIMS ANY PERSONAL LIABILITY, LOSS OR RISK
    INCURRED AS A CONSEQUENCE OF THE USE AND APPLICATION, EITHER DIRECTLY
    OR INDIRECTLY, OF THE CONTENT. THE AUTHOR SPECIFICALLY DISCLAIMS ANY
    REPRESENTATION, WHETHER EXPLICIT OR IMPLIED, THAT APPLYING THE CONTENT
    WILL LEAD TO SIMILAR RESULTS IN A BUSINESS SETTING. THE RESULTS PRESENTED
    IN THE CONTENT ARE NOT NECESSARILY TYPICAL AND SHOULD NOT DETERMINE
    EXPECTATIONS OF FINANCIAL OR BUSINESS RESULTS.
#+end_export

* Motivation
** Dummy citation

- this is a dummy citation

  \cite{Revesz:88}

** What is this?
#+begin_src R :session *R* :exports both :results output :eval no
Y(\(r) \(n)
    `zerop?`(n)(C0)
    (`IF`(eq(n)(C1))
	(C1)
	(\(x) add (r( sub(n)(C1) )) (r( sub(n)(C2) )) (x)))) 
#+end_src

#+RESULTS:
: 
: 

** It's R!
#+begin_src R :session *R* :exports both :results output :eval no
Y(\(r) \(n)
    `zerop?`(n)(C0)
    (`IF`(eq(n)(C1))
	(C1)
	(\(x) add (r( sub(n)(C1) )) (r( sub(n)(C2) )) (x)))) (C10) |> .to.integer ()
#+end_src

#+RESULTS:
: 
: [1] 55

** Similarities...
- R

    #+begin_src R :session *R* :exports both :results output :eval no
    Y(\(r) \(n)
	`zerop?`(n)(C0)
	(`IF`(eq(n)(C1))
	    (C1)
	    (\(x) add (r( sub(n)(C1) )) (r( sub(n)(C2) )) (x)))) (C10) |> .to.integer ()
    #+end_src

    #+RESULTS:
    : 
    : [1] 55

- \onslide<2-> Lisp

    #+begin_src emacs-lisp :exports both :results output :eval no
    (defun fibonacci (n)
	(if (or (= n 0) (= n 1)) n
	    (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))

    (print (fibonacci 10))
    #+end_src

    #+RESULTS:
    : 
    : 55

* Lambda Calculus: Theory
** Functions
- Mathematics
  
  $$x \mapsto x^2$$

- \onslide<2-> Haskell

    #+begin_src haskell :exports both :results output :eval no
    (\x -> x^2) 3
    #+end_src

    #+RESULTS:
    : 9

- \onslide<3-> R

    #+begin_src R :session *R* :exports both :results output :eval no
    (\(x) x^2) (3)
    #+end_src

    #+RESULTS:
    : [1] 9

** Functions
- Mathematics
  
  $$x \mapsto x^2$$

- Haskell

    #+begin_src haskell :exports both :results output :eval no
    (\x -> x^2) 3
    #+end_src

    #+RESULTS:
    : 9

- R

    #+begin_src R :session *R* :exports both :results output :eval no
    (function(x) x^2) (3)
    #+end_src

    #+RESULTS:
    : [1] 9

** Haskell: ~Int~
- Mathematics: constrain $x$
  
  $$x \mapsto x^2,\quad\forall x\in\NN$$

- \onslide<2-> type is metadata

    #+begin_src haskell :exports both :results output :eval no
    :{
      sq :: Int -> Int
      sq = \x -> x^2
    :}
    sq 3
    #+end_src

    #+RESULTS:
    : 9

** Haskell: ~Double~
- Mathematics: constrain $x$
  
  $$x \mapsto x^2,\quad\forall x\in\RR$$

- \onslide<2-> type is metadata

    #+begin_src haskell :exports both :results output :eval no
    :{
      sq :: Double -> Double
      sq = \x -> x^2
    :}
    sq 3
    #+end_src

    #+RESULTS:
    : 9.0

** Haskell: ~Num~
- Mathematics: what if there is no constraint on $x$?
  
  $$x \mapsto x^2,\quad\forall x\in\;???$$

- \onslide<2-> Haskell infers type

    #+begin_src haskell :exports both :results output :eval no
    :type \x -> x^2
    #+end_src

    \pause
    
    #+RESULTS:
    : \x -> x^2 :: Num a => a -> a

- \onslide<3-> type is metadata

    #+begin_src haskell :exports both :results output :eval no
    :{
      sq :: Num a => a -> a
      sq x = x^2
    :}
    sq 3
    #+end_src

    #+RESULTS:
    : 9

** Haskell: What is ~Num~?
- \onslide<2-> ~Num~ is a /type class/

    #+begin_src haskell :exports both :results output :eval no
    :info Num
    #+end_src

    #+LATEX: {\tiny
    #+RESULTS:
    #+begin_example
    class Num a where
      (+) :: a -> a -> a
      (-) :: a -> a -> a
      (*) :: a -> a -> a
      negate :: a -> a
      abs :: a -> a
      signum :: a -> a
      fromInteger :: Integer -> a
      {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
	    -- Defined in ‘GHC.Num’
    instance Num Word -- Defined in ‘GHC.Num’
    instance Num Integer -- Defined in ‘GHC.Num’
    instance Num Int -- Defined in ‘GHC.Num’
    instance Num Float -- Defined in ‘GHC.Float’
    instance Num Double -- Defined in ‘GHC.Float’
    #+end_example
    #+LATEX: }

** Haskell: What is ~Int~?
- ~Int~ is a /data constructor/: it is an /instance/ of type class ~Num~

    #+begin_src haskell :exports both :results output :eval no
    :info Int
    #+end_src

    #+LATEX: {\tiny
    #+RESULTS:
    #+begin_example
    data Int = GHC.Types.I# GHC.Prim.Int# 	-- Defined in ‘GHC.Types’
    instance Eq Int -- Defined in ‘GHC.Classes’
    instance Ord Int -- Defined in ‘GHC.Classes’
    instance Enum Int -- Defined in ‘GHC.Enum’
    instance Num Int -- Defined in ‘GHC.Num’
    instance Real Int -- Defined in ‘GHC.Real’
    instance Show Int -- Defined in ‘GHC.Show’
    instance Integral Int -- Defined in ‘GHC.Real’
    instance Bounded Int -- Defined in ‘GHC.Enum’
    instance Read Int -- Defined in ‘GHC.Read’
    #+end_example
    #+LATEX: }

** Haskell: What is ~Double~?
- ~Double~ is a /data constructor/: it is an /instance/ of type class ~Num~

    #+begin_src haskell :exports both :results output :eval no
    :info Double
    #+end_src

    #+LATEX: {\tiny
    #+RESULTS:
    #+begin_example
    data Double = GHC.Types.D# GHC.Prim.Double#
	    -- Defined in ‘GHC.Types’
    instance Eq Double -- Defined in ‘GHC.Classes’
    instance Ord Double -- Defined in ‘GHC.Classes’
    instance Enum Double -- Defined in ‘GHC.Float’
    instance Floating Double -- Defined in ‘GHC.Float’
    instance Fractional Double -- Defined in ‘GHC.Float’
    instance Num Double -- Defined in ‘GHC.Float’
    instance Real Double -- Defined in ‘GHC.Float’
    instance RealFloat Double -- Defined in ‘GHC.Float’
    instance RealFrac Double -- Defined in ‘GHC.Float’
    instance Show Double -- Defined in ‘GHC.Float’
    instance Read Double -- Defined in ‘GHC.Read’
    #+end_example
    #+LATEX: }

** Back to functions...
- Mathematics
  
  $$x \mapsto x^2$$

- R

    #+begin_src R :session *R* :exports both :results output :eval no
    (\(x) x^2) (3)
    #+end_src

    #+RESULTS:
    : [1] 9

** What if we /only/ had functions?
- Mathematics
  
  $$x \mapsto x$$

- R

    #+begin_src R :session *R* :exports both :results output :eval no
    \(x) x
    #+end_src

    #+RESULTS:
    : \(x) x

** Backus-Naur Form
#+begin_src haskell :exports both :results output :eval yes
(\x -> x^2) 3
#+end_src

#+RESULTS:
: 9

* Lambda Calculus: Implementation
** Switching between worlds: utilities
* Lisp
** Fibonacci: Lisp
    #+begin_src emacs-lisp :exports both :results output :eval no
    (defun fibonacci (n)
	(if (or (= n 0) (= n 1)) n
	    (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))
    #+end_src

    #+RESULTS:

** Fibonacci: Lisp
    #+begin_src emacs-lisp :exports both :results output :eval no
    (defun fibonacci (n)
	(if (or (= n 0) (= n 1)) n
	    (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))

    (let ((x '(0 1 2 3 4 5 6 7 8 9 10)))
    (mapcar (lambda (x) (princ (format "%2s:%3s\n" x (fibonacci x)))) x))
    #+end_src

    #+RESULTS:
    #+begin_example
    0:  0
    1:  1
    2:  1
    3:  2
    4:  3
    5:  5
    6:  8
    7: 13
    8: 21
    9: 34
    10: 55
    #+end_example

* References 
 
#+BIBLIOGRAPHY: /home/tharte/dot/include/refs cell limit:t

